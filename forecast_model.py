"""\nDemand Forecasting Model for Supply Chain Optimization\nImplements LSTM and Prophet models for time series forecasting\n\nAuthor: Satish Kumar Soni\n"""\n\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Deep Learning\nfrom tensorflow import keras\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import LSTM, Dense, Dropout\nfrom sklearn.preprocessing import MinMaxScaler\n\n# Time Series\ntry:\n    from prophet import Prophet\nexcept ImportError:\n    from fbprophet import Prophet\n\n# Visualization\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Metrics\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\n\n\nclass DemandForecaster:\n    \"\"\"\n    Advanced demand forecasting system using multiple ML models\n    \"\"\"\n    \n    def __init__(self, data=None):\n        self.data = data\n        self.scaler = MinMaxScaler()\n        self.lstm_model = None\n        self.prophet_model = None\n        self.results = {}\n        \n    def load_data(self, filepath=None, date_col='date', demand_col='demand'):\n        \"\"\"Load and prepare time series data\"\"\"\n        if filepath:\n            self.data = pd.read_csv(filepath)\n            self.data[date_col] = pd.to_datetime(self.data[date_col])\n            self.data = self.data.sort_values(date_col)\n        \n        self.date_col = date_col\n        self.demand_col = demand_col\n        return self\n    \n    def generate_sample_data(self, days=365*2):\n        \"\"\"Generate synthetic demand data for demonstration\"\"\"\n        np.random.seed(42)\n        dates = pd.date_range(start='2022-01-01', periods=days, freq='D')\n        \n        # Base demand with trend and seasonality\n        trend = np.linspace(100, 150, days)\n        seasonal = 20 * np.sin(2 * np.pi * np.arange(days) / 365)\n        weekly = 10 * np.sin(2 * np.pi * np.arange(days) / 7)\n        noise = np.random.normal(0, 5, days)\n        \n        demand = trend + seasonal + weekly + noise\n        demand = np.maximum(demand, 0)  # Ensure non-negative\n        \n        self.data = pd.DataFrame({\n            'date': dates,\n            'demand': demand\n        })\n        \n        self.date_col = 'date'\n        self.demand_col = 'demand'\n        return self\n    \n    def prepare_lstm_data(self, lookback=30, train_size=0.8):\n        \"\"\"Prepare data for LSTM model\"\"\"\n        values = self.data[self.demand_col].values.reshape(-1, 1)\n        scaled_data = self.scaler.fit_transform(values)\n        \n        X, y = [], []\n        for i in range(lookback, len(scaled_data)):\n            X.append(scaled_data[i-lookback:i, 0])\n            y.append(scaled_data[i, 0])\n        \n        X, y = np.array(X), np.array(y)\n        X = X.reshape(X.shape[0], X.shape[1], 1)\n        \n        split = int(train_size * len(X))\n        self.X_train, self.X_test = X[:split], X[split:]\n        self.y_train, self.y_test = y[:split], y[split:]\n        \n        return self\n    \n    def build_lstm_model(self, units=50, dropout=0.2):\n        \"\"\"Build LSTM neural network\"\"\"\n        model = Sequential([\n            LSTM(units, return_sequences=True, input_shape=(self.X_train.shape[1], 1)),\n            Dropout(dropout),\n            LSTM(units, return_sequences=False),\n            Dropout(dropout),\n            Dense(25),\n            Dense(1)\n        ])\n        \n        model.compile(optimizer='adam', loss='mean_squared_error')\n        self.lstm_model = model\n        return self\n    \n    def train_lstm(self, epochs=50, batch_size=32, verbose=0):\n        \"\"\"Train LSTM model\"\"\"\n        if not self.lstm_model:\n            self.build_lstm_model()\n        \n        history = self.lstm_model.fit(\n            self.X_train, self.y_train,\n            batch_size=batch_size,\n            epochs=epochs,\n            validation_data=(self.X_test, self.y_test),\n            verbose=verbose\n        )\n        \n        self.results['lstm_history'] = history\n        return self\n    \n    def predict_lstm(self, steps=30):\n        \"\"\"Generate LSTM predictions\"\"\"\n        predictions = self.lstm_model.predict(self.X_test)\n        predictions = self.scaler.inverse_transform(predictions)\n        \n        self.results['lstm_predictions'] = predictions\n        return predictions\n    \n    def train_prophet(self):\n        \"\"\"Train Prophet model\"\"\"\n        df_prophet = self.data[[self.date_col, self.demand_col]].copy()\n        df_prophet.columns = ['ds', 'y']\n        \n        self.prophet_model = Prophet(\n            daily_seasonality=True,\n            weekly_seasonality=True,\n            yearly_seasonality=True,\n            seasonality_mode='multiplicative'\n        )\n        \n        self.prophet_model.fit(df_prophet)\n        return self\n    \n    def predict_prophet(self, periods=30):\n        \"\"\"Generate Prophet predictions\"\"\"\n        future = self.prophet_model.make_future_dataframe(periods=periods)\n        forecast = self.prophet_model.predict(future)\n        \n        self.results['prophet_forecast'] = forecast\n        return forecast\n    \n    def evaluate_models(self):\n        \"\"\"Calculate evaluation metrics\"\"\"\n        y_test_actual = self.scaler.inverse_transform(self.y_test.reshape(-1, 1))\n        lstm_pred = self.results.get('lstm_predictions', [])\n        \n        if len(lstm_pred) > 0:\n            mae = mean_absolute_error(y_test_actual, lstm_pred)\n            rmse = np.sqrt(mean_squared_error(y_test_actual, lstm_pred))\n            r2 = r2_score(y_test_actual, lstm_pred)\n            \n            self.results['metrics'] = {\n                'MAE': mae,\n                'RMSE': rmse,\n                'R2': r2\n            }\n            \n        return self.results.get('metrics', {})\n    \n    def plot_results(self, save_path=None):\n        \"\"\"Visualize forecasting results\"\"\"\n        fig, axes = plt.subplots(2, 2, figsize=(15, 10))\n        \n        # Original time series\n        axes[0, 0].plot(self.data[self.date_col], self.data[self.demand_col])\n        axes[0, 0].set_title('Historical Demand')\n        axes[0, 0].set_xlabel('Date')\n        axes[0, 0].set_ylabel('Demand')\n        axes[0, 0].grid(True)\n        \n        # LSTM predictions\n        if 'lstm_predictions' in self.results:\n            y_test_actual = self.scaler.inverse_transform(self.y_test.reshape(-1, 1))\n            axes[0, 1].plot(y_test_actual, label='Actual')\n            axes[0, 1].plot(self.results['lstm_predictions'], label='LSTM Forecast')\n            axes[0, 1].set_title('LSTM Model Predictions')\n            axes[0, 1].legend()\n            axes[0, 1].grid(True)\n        \n        # Prophet forecast\n        if 'prophet_forecast' in self.results:\n            forecast = self.results['prophet_forecast']\n            axes[1, 0].plot(self.data[self.date_col], self.data[self.demand_col], label='Actual')\n            axes[1, 0].plot(forecast['ds'], forecast['yhat'], label='Prophet Forecast')\n            axes[1, 0].fill_between(forecast['ds'], forecast['yhat_lower'], \n                                   forecast['yhat_upper'], alpha=0.3)\n            axes[1, 0].set_title('Prophet Model Forecast')\n            axes[1, 0].legend()\n            axes[1, 0].grid(True)\n        \n        # Metrics\n        if 'metrics' in self.results:\n            metrics = self.results['metrics']\n            metrics_text = f\"MAE: {metrics['MAE']:.2f}\\nRMSE: {metrics['RMSE']:.2f}\\nR²: {metrics['R2']:.4f}\"\n            axes[1, 1].text(0.5, 0.5, metrics_text, ha='center', va='center', \n                          fontsize=14, bbox=dict(boxstyle='round', facecolor='wheat'))\n            axes[1, 1].set_title('Model Performance Metrics')\n            axes[1, 1].axis('off')\n        \n        plt.tight_layout()\n        \n        if save_path:\n            plt.savefig(save_path, dpi=300, bbox_inches='tight')\n        \n        return fig\n\n\nif __name__ == \"__main__\":\n    # Example usage\n    print(\"Initializing Demand Forecasting System...\")\n    \n    forecaster = DemandForecaster()\n    forecaster.generate_sample_data(days=730)\n    \n    print(\"Training LSTM model...\")\n    forecaster.prepare_lstm_data(lookback=30)\n    forecaster.build_lstm_model(units=50)\n    forecaster.train_lstm(epochs=50, batch_size=32, verbose=1)\n    \n    print(\"\\nGenerating LSTM predictions...\")\n    forecaster.predict_lstm()\n    \n    print(\"Training Prophet model...\")\n    forecaster.train_prophet()\n    forecaster.predict_prophet(periods=90)\n    \n    print(\"\\nEvaluating models...\")\n    metrics = forecaster.evaluate_models()\n    print(f\"Model Performance:\")\n    print(f\"MAE: {metrics['MAE']:.2f}\")\n    print(f\"RMSE: {metrics['RMSE']:.2f}\")\n    print(f\"R²: {metrics['R2']:.4f}\")\n    \n    print(\"\\nGenerating visualizations...\")\n    forecaster.plot_results('forecast_results.png')\n    \n    print(\"\\nForecasting complete!\")
